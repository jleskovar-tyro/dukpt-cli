#!/usr/bin/env node
(()=>{var e={770:(e,t,s)=>{const r=s(417),n=s(419);e.exports=class{static generateCryptojs(e,t){const s=n.enc.Hex.parse(e.substring(0,16)),r=n.enc.Hex.parse(e.substring(16)),a=n.enc.Hex.parse("0000000000000000");let o=n.DES.encrypt(n.enc.Utf8.parse(t),s,{iv:a,mode:n.mode.CBC,padding:n.pad.ZeroPadding});return o=n.DES.decrypt({ciphertext:n.enc.Hex.parse(o.ciphertext.toString().slice(-16))},r,{mode:n.mode.ECB,padding:n.pad.NoPadding}),o=n.DES.encrypt(o,s,{mode:n.mode.ECB,padding:n.pad.NoPadding}),o.ciphertext.toString().toUpperCase()}static generate(e,t){const s=Buffer.from(e._sessionKey.substring(0,16),"hex"),n=Buffer.from(e._sessionKey.substring(16),"hex"),a=Buffer.alloc(8,0);if((t=Buffer.from(t,"utf8")).length%8>0){let e=Buffer.alloc(8-t.length%8,0);t=Buffer.concat([t,e])}let o,c;return o=r.createCipheriv("des-cbc",s,a).setAutoPadding(!1),c=Buffer.concat([o.update(t),o.final()]),o=r.createDecipheriv("des-ecb",n,"").setAutoPadding(!1),c=Buffer.concat([o.update(c.slice(c.length-8)),o.final()]),o=r.createCipheriv("des-ecb",s,"").setAutoPadding(!1),c=Buffer.concat([o.update(c),o.final()]),c.toString("hex").toUpperCase()}}},600:(e,t,s)=>{const r=s(870),n=s(631),{PromiseSocket:a}=s(624),o=s(717);class c{constructor(e,t){this.host=e,this.port=t,this.debug=process.env.DUKPT_DEBUG||!1}async translatePinBlock(e,t,s,r,n,a){const o=c.makePinTranslateCommand();o.allocate();let i=o.buffer(),d=o.fields;return d.length=i.length-2,d.header="HDR0",d.command="G0",d.sourceBdk=e,d.destBdkFlag="*",d.destBdk=s,d.srcKsnDescriptor="906",d.srcKsn=t,d.dstKsnDescriptor="906",d.dstKsn=r,d.srcPinBlock=a,d.srcPinBlockFormat="01",d.dstPinBlockFormat="01",d.accountNumber=n.slice(n.length-13,-1),await this.sendRequestAndHandleHsmResponse(i,c.makePinTranslateResponse,(e=>e.pinBlock))}async generateMac(e,t,s){const r=c.makeGenerateMacRequest();r.allocate();let n=r.buffer(),a=r.fields;a.header="HDR0",a.command="GW",a.macMode="4",a.macMethod="1",a.bdk=e,a.ksnDescriptor="906",a.ksn=t;let o=Buffer.from(s,"utf8");return o.length%8>0&&(o=Buffer.concat([o,Buffer.alloc(8-o.length%8,0)])),a.length=n.length+o.length-2,a.messageLength=o.length.toString().padStart(4,"0"),n=Buffer.concat([n,o]),await this.sendRequestAndHandleHsmResponse(n,c.makeGenerateMacResponse,(e=>e.mac))}async encrypytData(e,t,s){const r=c.makeEncryptCommand();r.allocate();let n=r.buffer(),a=r.fields;a.header="HDR0",a.command="M0",a.modeFlag="01",a.inputFormatFlag="2",a.outputFormatFlag="1",a.keyType="009",a.key=e,a.ksnDescriptor="906",a.ksn=t,a.iv="0000000000000000";let o=Buffer.from(s,"utf8");return o.length%8>0&&(o=Buffer.concat([o,Buffer.alloc(8-o.length%8,0)])),a.length=n.length+o.length-2,a.messageLength=o.length.toString().padStart(4,"0"),n=Buffer.concat([n,o]),await this.sendRequestAndHandleHsmResponse(n,c.makeEncryptResponse,((e,t)=>t.slice(30).toString("hex")))}async decrypytData(e,t,s){const r=c.makeEncryptCommand();r.allocate();let n=r.buffer(),a=r.fields;a.header="HDR0",a.command="M2",a.modeFlag="01",a.inputFormatFlag="0",a.outputFormatFlag="2",a.keyType="009",a.key=e,a.ksnDescriptor="906",a.ksn=t,a.iv="0000000000000000";let o=Buffer.from(s,"hex");return a.length=n.length+o.length-2,a.messageLength=o.length.toString().padStart(4,"0"),n=Buffer.concat([n,o]),await this.sendRequestAndHandleHsmResponse(n,c.makeEncryptResponse,((e,t)=>t.slice(30).toString("utf8")))}verifyMac(e,t,s){}async sendRequestAndHandleHsmResponse(e,t,s){const r=new n.Socket,i=new a(r);try{await i.connect(this.port,this.host),this.debug&&(console.log("Sending HSM request:"),console.log(o.hexy(e))),await i.write(e);for(let e;e=await i.read();){let r=c.makeBaseResponse();return this.debug&&(console.log("Processing HSM response:"),console.log(o.hexy(e))),r._setBuff(e),"00"!==r.fields.errorCode?(console.error("HSM returned error code: "+r.fields.errorCode),null):(r=t(),r._setBuff(e),s(r.fields,e))}}catch(e){return console.error("HSM Error: "+e),null}finally{await i.destroy()}}static makeEncryptCommand(){return r().word16Sbe("length").chars("header",4).chars("command",2).chars("modeFlag",2).chars("inputFormatFlag",1).chars("outputFormatFlag",1).chars("keyType",3).chars("key",33).chars("ksnDescriptor",3).chars("ksn",20).chars("iv",16).chars("messageLength",4)}static makeEncryptResponse(){return r().word16Sbe("length").chars("header",4).chars("responseCode",2).chars("errorCode",2).chars("iv",16).chars("messageLength",4)}static makePinTranslateCommand(){return r().word16Sbe("length").chars("header",4).chars("command",2).chars("sourceBdk",33).chars("destBdkFlag",1).chars("destBdk",33).chars("srcKsnDescriptor",3).chars("srcKsn",20).chars("dstKsnDescriptor",3).chars("dstKsn",20).chars("srcPinBlock",16).chars("srcPinBlockFormat",2).chars("dstPinBlockFormat",2).chars("accountNumber",12)}static makePinTranslateResponse(){return r().word16Sbe("length").chars("header",4).chars("responseCode",2).chars("errorCode",2).chars("pinLength",2).chars("pinBlock",16)}static makeGenerateMacRequest(){return r().word16Sbe("length").chars("header",4).chars("command",2).chars("macMode",1).chars("macMethod",1).chars("bdk",33).chars("ksnDescriptor",3).chars("ksn",20).chars("messageLength",4)}static makeGenerateMacResponse(){return r().word16Sbe("length").chars("header",4).chars("responseCode",2).chars("errorCode",2).chars("mac",16)}static makeBaseResponse(){return r().word16Sbe("length").chars("header",4).chars("responseCode",2).chars("errorCode",2)}}e.exports=c},301:(e,t,s)=>{const r=s(747);e.exports=class{static parseInputData(e){return"-"===e?r.readFileSync(0).toString():e}}},306:e=>{"use strict";e.exports=JSON.parse('{"name":"dukpt-cli","version":"0.2.0","description":"DUKPT / Thales HSM Payshield 9000 cli","main":"dist/dukpt.js","scripts":{"build":"rimraf dist && webpack-cli --mode production","test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+https://github.com/jleskovar-tyro/dukpt-cli.git"},"files":["dist"],"keywords":["dukpt","cli","hsm","thales"],"author":"James Leskovar","license":"ISC","bugs":{"url":"https://github.com/jleskovar-tyro/dukpt-cli/issues"},"homepage":"https://github.com/jleskovar-tyro/dukpt-cli#readme","dependencies":{"commander":"^7.1.0","crypto-js":"^4.0.0","cryptojs":"^2.5.3","data-crypto":"^1.4.3","dukpt":"^3.0.0","hexy":"^0.3.1","omelette":"^0.4.15-1","promise-socket":"^7.0.0","struct":"^0.0.12"},"bin":{"dukpt":"dist/dukpt.js"},"devDependencies":{"@babel/core":"^7.13.10","@babel/preset-env":"^7.13.10","babel-loader":"^8.2.2","rimraf":"^3.0.2","webpack":"^5.25.0","webpack-cli":"^4.5.0","webpack-node-externals":"^2.5.2"}}')},647:e=>{"use strict";e.exports=require("commander")},417:e=>{"use strict";e.exports=require("crypto")},419:e=>{"use strict";e.exports=require("crypto-js")},172:e=>{"use strict";e.exports=require("data-crypto")},311:e=>{"use strict";e.exports=require("dukpt")},747:e=>{"use strict";e.exports=require("fs")},717:e=>{"use strict";e.exports=require("hexy")},631:e=>{"use strict";e.exports=require("net")},374:e=>{"use strict";e.exports=require("omelette")},624:e=>{"use strict";e.exports=require("promise-socket")},870:e=>{"use strict";e.exports=require("struct")}},t={};function s(r){var n=t[r];if(void 0!==n)return n.exports;var a=t[r]={exports:{}};return e[r](a,a.exports,s),a.exports}(()=>{const{program:e,Option:t}=s(647),{version:r}=s(306),n=s(311),{pinBlockFormat0:a}=s(172),o=s(770),c=s(301),i=s(600),d=s(374),p={encryptionMode:"3DES",outputEncoding:"hex",inputEncoding:"ascii"};e.version(r).addOption(new t("--debug","output extra debugging").default(!1)).addOption(new t("-h, --hsm-host <host>","Thales HSM host to connect to, for HSM commands").default("hsm")).addOption(new t("-p, --hsm-port <port>","Thales HSM port to connect to, for HSM commands").default(80)).addOption(new t("-e, --encryption <mode>","encryption mode").choices(["3DES","AES"]).default("3DES")),e.on("option:debug",(()=>{process.env.DUKPT_DEBUG=!0})),e.command("init").description("install shell completion").action((()=>{l.setupShellInitFile()})),e.command("pin <bdk> <ksn> <accountNumber> <pinDigits>").description('generate encrypted ISO "Format 0" PIN block').action(((e,t,s,r)=>{const o=new n(e,t,"pinkey");let c=a(s,r);console.log(o.dukptEncrypt(c,{...p,inputEncoding:"hex"}))})),e.command("mac <bdk> <ksn> <data>").description("generate MAC").action(((e,t,s)=>{const r=new n(e,t,"mackey");console.log(o.generate(r,c.parseInputData(s)))})),e.command("mac-cryptojs <bdk> <ksn> <data>").description("generate MAC [CryptoJS]").action(((e,t,s)=>{const r=new n(e,t,"mackey");console.log(o.generateCryptojs(r._sessionKey,c.parseInputData(s)))})),e.command("encrypt <bdk> <ksn> <data>").description("encrypt data").action(((e,t,s)=>{const r=new n(e,t,"datakey");console.log(r.dukptEncrypt(c.parseInputData(s),{...p}))})),e.command("decrypt <bdk> <ksn> <data>").description("decrypt data").action(((e,t,s)=>{const r=new n(e,t,"datakey");console.log(r.dukptDecrypt(c.parseInputData(s),{inputEncoding:"hex",outputEncoding:"ascii",trimOutput:!0}))})),e.command("hsm-pin-trans <srcBdk> <srcKsn> <dstBdk> <dstKsn> <accountNumber> <srcPinBlock>").description("Translate encrypted BDK from type-1 source BDK to another type-1 BDK [G0 command]").action((async(t,s,r,n,a,o)=>{const c=new i(e.opts().hsmHost,e.opts().hsmPort),d=await c.translatePinBlock(t,s,r,n,a,o);console.log(d)})),e.command("hsm-gen-mac <encryptedBdk> <ksn> <data>").description("Generate MAC (Mode 4: 8-byte MAC) [GW command]").action((async(t,s,r)=>{const n=new i(e.opts().hsmHost,e.opts().hsmPort);r=c.parseInputData(r);const a=await n.generateMac(t,s,r);console.log(a)})),e.command("hsm-encrypt <encryptedBdk> <ksn> <data>").description("Encrypt Data [M0 command]").action((async(t,s,r)=>{const n=new i(e.opts().hsmHost,e.opts().hsmPort);r=c.parseInputData(r);const a=await n.encrypytData(t,s,r);console.log(a)})),e.command("hsm-decrypt <encryptedBdk> <ksn> <data>").description("Decrypt Data [M2 command]").action((async(t,s,r)=>{const n=new i(e.opts().hsmHost,e.opts().hsmPort);r=c.parseInputData(r);const a=await n.decrypytData(t,s,r);console.log(a)}));const l=d("dukpt <action>");l.on("action",(({reply:t})=>{t(e.commands.map((e=>e.name())))})),l.init(),e.parse(process.argv)})()})();